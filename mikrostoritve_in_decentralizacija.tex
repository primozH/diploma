%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% datoteka diploma-vzorec.tex
%
% vzorčna datoteka za pisanje diplomskega dela v formatu LaTeX
% na UL Fakulteti za računalništvo in informatiko
%
% vkup spravil Gašper Fijavž, december 2010
% 
%
%
% verzija 12. februar 2014 (besedilo teme, seznam kratic, popravki Gašper Fijavž)
% verzija 10. marec 2014 (redakcijski popravki Zoran Bosnić)
% verzija 11. marec 2014 (redakcijski popravki Gašper Fijavž)
% verzija 15. april 2014 (pdf/a 1b compliance, not really - just claiming, Damjan Cvetan, Gašper Fijavž)
% verzija 23. april 2014 (privzeto cc licenca)
% verzija 16. september 2014 (odmiki strain od roba)
% verzija 28. oktober 2014 (odstranil vpisno številko)
% verija 5. februar 2015 (Literatura v kazalu, online literatura)
% verzija 25. september 2015 (angl. naslov v izjavi o avtorstvu)
% verzija 26. februar 2016 (UL izjava o avtorstvu)
% verzija 16. april 2016 (odstranjena izjava o avtorstvu)
% verzija 5. junij 2016 (Franc Solina dodal vrstice, ki jih je označil s svojim imenom)


\documentclass[a4paper, 12pt]{book}
%\documentclass[a4paper, 12pt, draft]{book}  Nalogo preverite tudi z opcijo draft, ki vam bo pokazala, katere vrstice so predolge!



\usepackage[utf8x]{inputenc}   % omogoča uporabo slovenskih črk kodiranih v formatu UTF-8
\usepackage[slovene,english]{babel}    % naloži, med drugim, slovenske delilne vzorce
\usepackage[pdftex]{graphicx}  % omogoča vlaganje slik različnih formatov
\usepackage{fancyhdr}          % poskrbi, na primer, za glave strani
\usepackage{amssymb}           % dodatni simboli
\usepackage{amsmath}           % eqref, npr.
%\usepackage{hyperxmp}
\usepackage[hyphens]{url}  % dodal Solina
\usepackage{comment}       % dodal Solina

\usepackage[pdftex, colorlinks=true,
						citecolor=black, filecolor=black, 
						linkcolor=black, urlcolor=black,
						pagebackref=false, 
						pdfproducer={LaTeX}, pdfcreator={LaTeX}, hidelinks]{hyperref}

\usepackage{color}       % dodal Solina
\usepackage{soul}       % dodal Solina
\usepackage{listings}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	DIPLOMA INFO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ttitle}{Mikrostoritve v decentraliziranem okolju}
\newcommand{\ttitleEn}{Microservices in decentralized environment}
\newcommand{\tsubject}{\ttitle}
\newcommand{\tsubjectEn}{\ttitleEn}
\newcommand{\tauthor}{Primož Hrovat}
\newcommand{\tkeywords}{decentralizacija, distribuirane storitve, tehnologija veriženja podatkovnih blokov}
\newcommand{\tkeywordsEn}{decentralization, distributed services, blockchain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	HYPERREF SETUP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypersetup{pdftitle={\ttitle}}
\hypersetup{pdfsubject=\ttitleEn}
\hypersetup{pdfauthor={\tauthor, ph0672@student.uni-lj.si}}
\hypersetup{pdfkeywords=\tkeywordsEn}


 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% postavitev strani
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

\addtolength{\marginparwidth}{-20pt} % robovi za tisk
\addtolength{\oddsidemargin}{40pt}
\addtolength{\evensidemargin}{-40pt}

\renewcommand{\baselinestretch}{1.3} % ustrezen razmik med vrsticami
\setlength{\headheight}{15pt}        % potreben prostor na vrhu
\renewcommand{\chaptermark}[1]%
{\markboth{\MakeUppercase{\thechapter.\ #1}}{}} \renewcommand{\sectionmark}[1]%
{\markright{\MakeUppercase{\thesection.\ #1}}} \renewcommand{\headrulewidth}{0.5pt} \renewcommand{\footrulewidth}{0pt}
\fancyhf{}
\fancyhead[LE,RO]{\sl \thepage} 
%\fancyhead[LO]{\sl \rightmark} \fancyhead[RE]{\sl \leftmark}
\fancyhead[RE]{\sc \tauthor}              % dodal Solina
\fancyhead[LO]{\sc Diplomska naloga}     % dodal Solina


\newcommand{\BibTeX}{{\sc Bib}\TeX}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% naslovi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  


\newcommand{\autfont}{\Large}
\newcommand{\titfont}{\LARGE\bf}
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}}
\setcounter{tocdepth}{1}	      % globina kazala

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% konstrukti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\newtheorem{izrek}{Izrek}[chapter]
\newtheorem{trditev}{Trditev}[izrek]
\newenvironment{dokaz}{\emph{Dokaz.}\ }{\hspace{\fill}{$\Box$}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PDF-A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% define medatata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\def\Title{\ttitle}
\def\Author{\tauthor, ph0672@student.uni-lj.si}
\def\Subject{\ttitleEn}
\def\Keywords{\tkeywordsEn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% \convertDate converts D:20080419103507+02'00' to 2008-04-19T10:35:07+02:00
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\def\convertDate{%
    \getYear
}

{\catcode`\D=12
 \gdef\getYear D:#1#2#3#4{\edef\xYear{#1#2#3#4}\getMonth}
}
\def\getMonth#1#2{\edef\xMonth{#1#2}\getDay}
\def\getDay#1#2{\edef\xDay{#1#2}\getHour}
\def\getHour#1#2{\edef\xHour{#1#2}\getMin}
\def\getMin#1#2{\edef\xMin{#1#2}\getSec}
\def\getSec#1#2{\edef\xSec{#1#2}\getTZh}
\def\getTZh +#1#2{\edef\xTZh{#1#2}\getTZm}
\def\getTZm '#1#2'{%
    \edef\xTZm{#1#2}%
    \edef\convDate{\xYear-\xMonth-\xDay T\xHour:\xMin:\xSec+\xTZh:\xTZm}%
}

\expandafter\convertDate\pdfcreationdate 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% get pdftex version string
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newcount\countA
\countA=\pdftexversion
\advance \countA by -100
\def\pdftexVersionStr{pdfTeX-1.\the\countA.\pdftexrevision}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% XMP data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\usepackage{xmpincl}
\includexmp{pdfa-1b}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% pdfInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\pdfinfo{%
    /Title    (\ttitle)
    /Author   (\tauthor, damjan@cvetan.si)
    /Subject  (\ttitleEn)
    /Keywords (\tkeywordsEn)
    /ModDate  (\pdfcreationdate)
    /Trapped  /False
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\selectlanguage{slovene}
\frontmatter
\setcounter{page}{1} %
\renewcommand{\thepage}{}       % preprecimo težave s številkami strani v kazalu
\newcommand{\sn}[1]{"`#1"'}                    % dodal Solina (slovenski narekovaji)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%naslovnica
 \thispagestyle{empty}%
   \begin{center}
    {\large\sc Univerza v Ljubljani\\%
      Fakulteta za računalništvo in informatiko}%
    \vskip 10em%
    {\autfont \tauthor\par}%
    {\titfont \ttitle \par}%
    {\vskip 3em \textsc{DIPLOMSKO DELO\\[5mm]         % dodal Solina za ostale študijske programe
%    VISOKOŠOLSKI STROKOVNI ŠTUDIJSKI PROGRAM\\ PRVE STOPNJE\\ RAČUNALNIŠTVO IN INFORMATIKA}\par}%
    UNIVERZITETNI  ŠTUDIJSKI PROGRAM\\ PRVE STOPNJE\\ RAČUNALNIŠTVO IN INFORMATIKA}\par}%
%    INTERDISCIPLINARNI UNIVERZITETNI\\ ŠTUDIJSKI PROGRAM PRVE STOPNJE\\ RAČUNALNIŠTVO IN MATEMATIKA}\par}%
%    INTERDISCIPLINARNI UNIVERZITETNI\\ ŠTUDIJSKI PROGRAM PRVE STOPNJE\\ UPRAVNA INFORMATIKA}\par}%
%    INTERDISCIPLINARNI UNIVERZITETNI\\ ŠTUDIJSKI PROGRAM PRVE STOPNJE\\ MULTIMEDIJA}\par}%
    \vfill\null%
    {\large \textsc{Mentor}: prof.  dr.  Matjaž Branko Jurič\par}%
  % {\large \textsc{Somentor}:  izr.\ prof.\ dr. Martin Krpan \par}%
    {\vskip 2em \large Ljubljana, 2018 \par}%
\end{center}
% prazna stran
%\clearemptydoublepage      % dodal Solina (izjava o licencah itd. se izpiše na hrbtni strani naslovnice)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%copyright stran
\thispagestyle{empty}
\vspace*{8cm}

\noindent
{\sc Copyright}. 
Rezultati diplomske naloge so intelektualna lastnina avtorja in Fakultete za računalništvo in informatiko Univerze v Ljubljani.
Za objavo in koriščenje rezultatov diplomske naloge je potrebno pisno privoljenje avtorja, Fakultete za računalništvo in informatiko ter mentorja.

\begin{center}
\mbox{}\vfill
\emph{Besedilo je oblikovano z urejevalnikom besedil \LaTeX.}
\end{center}
% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% stran 3 med uvodnimi listi
\thispagestyle{empty}
\vspace*{4cm}

\noindent
Fakulteta za računalništvo in informatiko izdaja naslednjo nalogo:
\medskip
\begin{tabbing}
\hspace{32mm}\= \hspace{6cm} \= \kill




Tematika naloge:
\end{tabbing}
Besedilo teme diplomskega dela študent prepiše iz študijskega informacijskega sistema, kamor ga je vnesel mentor. V nekaj stavkih bo opisal, kaj pričakuje od kandidatovega diplomskega dela. Kaj so cilji, kakšne metode uporabiti, morda bo zapisal tudi ključno literaturo.

\textbf{TODO:} dopolni z opisom, ko bo na voljo
\vspace{15mm}



\vspace{2cm}

% prazna stran
\clearemptydoublepage

% zahvala
\thispagestyle{empty}\mbox{}\vfill\null\it%
\noindent
Na tem mestu zapišite, komu se zahvaljujete za izdelavo diplomske naloge. Pazite, da ne boste koga pozabili. Utegnil vam bo zameriti. Temu se da izogniti tako, da celotno zahvalo izpustite.
\rm\normalfont

% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% posvetilo, če sama zahvala ne zadošča :-)
\thispagestyle{empty}\mbox{}{\vskip0.20\textheight}\mbox{}\hfill\begin{minipage}{0.55\textwidth}%
Posvetilo
\normalfont\end{minipage}

% prazna stran
\clearemptydoublepage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kazalo
\pagestyle{empty}
\def\thepage{}% preprecimo tezave s stevilkami strani v kazalu
\tableofcontents{}


% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% seznam kratic

\chapter*{Seznam uporabljenih kratic}  % spremenil Solina, da predolge vrstice ne gredo preko desnega roba
\textbf{TODO:} dopolni

\begin{comment}
\begin{tabular}{l|l|l}
  {\bf kratica} & {\bf angleško} & {\bf slovensko} \\ \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  {\bf CA} & classification accuracy & klasifikacijska točnost \\
  {\bf DBMS} & database management system & sistem za upravljanje podatkovnih baz \\
  {\bf SVM} & support vector machine & metoda podpornih vektorjev \\
  \dots & \dots & \dots \\
\end{tabular}
\end{comment}

\noindent\begin{tabular}{p{0.1\textwidth}|p{.4\textwidth}|p{.4\textwidth}}    % po potrebi razširi prvo kolono tabele na račun drugih dveh!
  {\bf kratica} & {\bf angleško}                             & {\bf slovensko} \\ \hline
  {\bf CA}      & classification accuracy               & klasifikacijska točnost \\
  {\bf DBMS} & database management system & sistem za upravljanje podatkovnih baz \\
  {\bf SVM}   & support vector machine              & metoda podpornih vektorjev \\
  \dots & \dots & \dots \\
\end{tabular}


% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% povzetek
\addcontentsline{toc}{chapter}{Povzetek}
\chapter*{Povzetek}

\noindent\textbf{Naslov:} \ttitle
\bigskip

\noindent\textbf{Avtor:} \tauthor
\bigskip

%\noindent\textbf{Povzetek:} 
\noindent

\textbf{TODO:} dopolni ob koncu

\bigskip

\noindent\textbf{Ključne besede:} \tkeywords.
% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% abstract
\selectlanguage{english}
\addcontentsline{toc}{chapter}{Abstract}
\chapter*{Abstract}

\noindent\textbf{Title:} \ttitleEn
\bigskip

\noindent\textbf{Author:} \tauthor
\bigskip

%\noindent\textbf{Abstract:} 
\noindent 
\textbf{TODO:} dopolni ob koncu

\bigskip

\noindent\textbf{Keywords:} \tkeywordsEn.
\selectlanguage{slovene}
% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter
\setcounter{page}{1}
\pagestyle{fancy}

\chapter{Uvod}
Poslovne storitve se danes selijo v oblak.
S pojavom arhitekture mikrostoritev in podporne tehnologije, kot so vsebniki in okolja za orkestracijo vsebnikov, so, nekdaj ogromni, kosi programske opreme pričeli razpadati na manjše, logično ločene sestavne dele.
Razmeroma majhne in neodvisne aplikacije, specializirane za opravljanje točno določenih nalog, omogočajo hiter vzpostavitveni čas in puščajo majhen odtis na porabi strojne opreme.
Neodvisnost teh aplikacij nam omogoča tudi skaliranje teh posamenznih delov celotne storitve, ko je to potrebno.
Vsebniki so razmeroma stara tehnologija, ki je s pojavom okolja Docker doživela pravi razcvet.
Gre za "lahko" obliko virtualizacije, virtualizacija tu poteka na nivoju procesov in ne operacijskega sistema.
Pravi potencial vsebnikov izkoristimo šele z uporabo orkestratorjev, kot so Kubernetes, Amazon ECS, Google Container Engine (GKE), Docker Swarm, Azure Container Service in podobni.
Ta orodja omogočajo monitoring, zaganjanje, zaustavljanje in preverjanje storitev, skladno s podanimi zahtevami.
Storitve se izvajajo distribuirano (porazdeljeno) in replicirano, lahko tudi na fizično ločenih sistemih, kar zagotavlja visoko stopnjo odzivnosti in dosegljivosti. Stopnja dosegljivosti se danes meri na peti ali šesti decimalki (\sn{number of nines}).

S pojavom Bitcoina se je začel razvoj tehnologije, ki v decentraliziranem okolju omogoča varno in nespremenljivo hrambo podatkov.
Veriženje podatkovnih blokov je v zadnjih letih s pojavom različnih organizacij kot so Hyperledger in Ethereum doživelo razcvet.
Nova tehnologija omogoča shranjevanje podatkov, repliciranih na vseh sodelujočih entitetah v omrežju, obenem pa ohranjajo nespremenljivost.

Tu se pojavlja vprašanje. 
Je možno tudi poslovno logiko prestaviti v decentralizirano okolje na način, da bo sodelujoči v omrežju ob klicu želene storitve vedno dobil odgovor, izvedla ga bo katerakoli entiteta, obenem pa zagotoviti pravilnost izvajana?
Z uresničitvijo tega cilja bi miselnost decentraliziranih podatkov prestavili nivo višje, na nivo poslovne logike.
Odzivnost in dosegljivost storitve bi s številom sodelujočih v omrežju dosegla 100\%, prav tako bi bilo praktično nemogoče izvesti napade DOS.

\textbf{TODO:} dopolni s podrobnostmi (ob koncu pisanja)


\chapter{Arhitekturni koncepti mikrostoritev}
\label{ch1}

Razvoj monolitov je enostaven in danes dobro podprt v vseh danes prisotnih razvojnih okoljih.
Prenos in namestitev teh storitev na strežniške sisteme je enostaven, rešitev v obliki izvršljivih datotek ali s kopiranjem direktorijske strukture prenesemo v produkcijsko izvajalno okolje.
Če želimo tako storitev skalirati, kot vstopno točko v naše zaledne sisteme nastavimo izenačevalnika obremenitev (ang. load balancer), ki poskrbi za enakomerno porazdeljevanje dela med posameznimi instancami storitve.

Slabosti te arhitekture se pojavijo, ko storitev postane kompleksnejša.
Podaljša se zagonski čas (start up time), ob preobremenitvi le enega dela storitve je potrebno pognati celotno aplikacijo.
Proces sprotne dostave (Continouos Delivery) je otežen, za posodobitev enega dela sistema, je potrebno celotno storitev zaustaviti, namestiti novo različico in jo zagnati. \cite{monolithMicroservice}


\section{Arhitektura mikrostoritev}

Arhitektura mikrostoritev omogoča...

\section{Vzorci}

\subsection{Metrike}

Posamezna storitev se lahko izvaja na različnih (fizičnih) lokacijah, na različni strojni opremi in v več instancah.
Pojavi se potreba po spremljanju storitve in njenega obnašanja, kje in zakaj prihaja do izpadov oziroma morebitnih dolgih odzivnih časih.
Vse želene metrike želimo shraniti na enem centraliziranem sistemu, jih po možnosti agregirati, in tako omogočiti odkrivanje napak in reševanje teh.
V osnovi poznamo dva modela zbiranja metrik: 
\begin{itemize}
	\item mikrostoritev sama pošilja metrike centralni zbirki (push)
	\item centralna zbirka zahteva metrike od storitve (pull)
\end{itemize}

Zbiranje metrik ponuja dober vpogled v obnašanje posameznih storitev, s sabo pa prinese dodatno potrebno infrastrukturo in dodatne težave pri implementaciji.\cite{ApplicationMetrics}


Ena izmed bolj znanih storitev za zbiranje aplikacijsih metrik je Prometheus, odprtokodna zbirka orodij za zbiranje in agregiranje metrik ter obveščanje.
Projekt je bil, takoj za orkestracijskim okoljem Kubernetes, pridružen fundaciji CNCF.
Prometheus zahteva metrike od storitve (način pull), jih agregira in proži morebitna opozorila.
Skupaj z ogrodjem Grafana omogoča celovit grafičen vpogled v zbrane metrike. \cite{Prometheus}


\subsection{Preverjanje (Health Check)}
\subsection{Odkrivanje storitev (Service discovery)}
\subsection{Odpornost na napake (Fault Tolerance)}

\section{Vsebniki in orkestracija}

\textbf{TODO:} dopolni s podrobnostmi (1. in 2. teden v juniju).


 \chapter{Tehnologija veriženja podatkovnih blokov}
\label{ch2}

Veriženje podatkovnih blokov je peer-to-peer porazdeljena podatkovna shramba, dosežena s konsenzom, sistemom "pametnih" pogodb ter drugih pomožnih tehnologij \cite{hyperledgerWeb}. Osrednja komponenta sistema je glavna knjiga (ang. ledger), ki beleži vse akcije (transakcije), izvedene na omrežju. \cite{hyperledgerDocs}
Entiteta, ki transakcijo izvede, jo podpiše s svojim privatnim ključem.
Skupek transakcij tvori podatkovni blok, bloki pa se med seboj povezujejo v podatkovno verigo.
Posamezne člene verige med seboj povezuje zgoščevalna funkcija, na vhod katere postavimo zgoščeno vrednost trenutnega in prejšnjega bloka.
Podatkovno verigo je moč vedno le podaljševati, trenutno veljavno in resnično stanje omrežja je trenutno najdaljša serija blokov.
Celotna veriga blokov je replicirana na vsaki izmed sodelujočih entiteti.

Kombinacija teh pristopov omogoča, da nobena izmed sodelujočih entitet ne more spreminjati že zapisanih blokov.
Napad na omrežje je možen le s pridobitvijo več kot polovice vseh sodelujočih entitet v omrežju, ki bi potrjevale resničnost ponarejenih transakcij in sčasoma sestavile daljšo podatkovno verigo, ki bi obveljala kot trenutna resnica.
S temi mehanizmi se zagotovi veljavnost in nespremenljivost podatkov v okolju, ki mu apriori ni potrebno zaupati.
Ni več potrebe po zunanji, zaupanja vredni, entiteti.

Za interakcijo z glavno knjigo in zapisovanje novih informacij, omrežje uporablja t.i. "pametne pogodbe". \cite{hyperledgerDocs}
To je del programske kode, ki se lahko odziva na dogodke v omrežju, izvede zapisano poslovno logiko ter ustvarja nove transakcije.\\

\section{Razlaga osnovnih konceptov}

\subsection{Glavna knjiga}

\subsection{Pametne pogodbe}

\subsection{Soglasje}

\subsection{Izvajalna okolja glede na zaupanje med udeleženci}
V grobem lahko, glede na stopnjo zaupanja, ločimo dva tipa izvajalnih okolij, ki ga udeleženci delijo med seboj.
Imamo omrežje, kjer so udeleženci vnaprej znani, identificirani s strani tretje osebe, ki ji zaupajo vsi sodelujoči.
Interakcije med njimi so varne v smislu prevzemanja odgovornosti.
Morebitna škodoželjnost udeleženca je enostavno kaznovana zaradi fizično overjenih oseb (pravnih ali fizičnih).

V javnih okoljih teh ugodnosti ne uživamo.
V omrežju lahko sodelujo kdorkoli in to povsem anonimno,
med udeleženci tako a priori velja načelo nezaupanja.
Zaupa se le stanju celotne podatkovne verige.
Tipično so za potrjevanje blokov in novih transakcij uporabljene \sn{kripto valute}, pridobljene s ti. postopkom rudarjenja.
Ta omrežja večinoma temeljijo na ??? (BFT). \cite{hyperledgerDocs}

\subsection{Zasebnost in zaupnost}
Javne podatkovne verige so replicirane na vseh sodelujočih entitetah, kar prinaša transparentnost, obenem pa poslovnim subjektom onemogoča učinkovito sklepanje dodatnih ugodnosti, aneksov ipd. s poslovnimi partnerji.
Ena od možnih rešitev problema je enkripcija podatkov, ki pa v tem primeru odpove.
Vsak izmed sodelujočih ima dostop do celotne glavne knjige, kar omogoča enostavne napade s silo.
V nadaljanju predstavljeno omrežje Fabric tu vpeljuje koncept kanalov.
Ti predstavljajo logično grupiranje posameznih entitet in omejujejo dostop do pametnih pogodb in glavne knjige na posameznem kanalu. \cite{hyperledgerDocs}

\section{Ethereum}
Ethereum je decentralizirana platforma, ki izvaja "pametne" pogodbe (smart contracts) - aplikacije, ki se izvajajo natanko tako, kot so bile zapisane.
Platforma je osnovana na verigi podatkovnih blokov, ki omogoča reprezentacijo in prenos vrednosti.
Lahko si ga predstavljamo kot svetovni računalnik, izvajanje programske kode pa poteka na vseh sodelujočih računalnikih.
Pametne pogodbe ponujajo možnost interakcije s podatkovno verigo, določeni deli kode pa se izvajajo le pod točno določenimi pogoji.

Stanje v Ethereum omrežju določajo objekti, znani kot uporabniški računi (accounts).
Vsak račun sestavlja 20 bajtov dolg naslov, prenos sredstev in informacij med računi pa predstavlja spremembo trenutnega stanja.
Uporabniške račune sestavljajo štiri polja:
\begin{itemize}
\item števec (nonce), ki preprečuje podvajanje transakcij
\item trenutno stanje Ethra (ether balance) trenutna količina ethra v lasti računa
\item pogodbena koda (contract code) opcijska
\item shramba (storage) privzeto prazno
\end{itemize}

Ether je interno plačilno sredstvo v omrežju.
Uporablja se kot nadomestilo za izvrševanje transakcij.
Ethereum pozna dva tipa uporabniških entitet: zunanje (externally owned), določenih s privatnimi ključi in pogodbene (contract accounts), določenih s kodo.
Zunanji računi ne obvladujejo kode, z ostalimi entitetami v omrežju pa lahko komunicirajo preko digitalno podpisanih transakcij.
Pametne pogodbe so entitete, ki se v omrežju odzivajo na vnaprej določena sporočila: izvedejo del logike, berejo in pišejo v glavno knjigo oziroma pošljejo novo sporočilo v omrežje.

\subsection{Komunikacija med entitetami}
V omrežju obstajata dva načina komunikacije: sporočila (messages) in transakcije (transactions).
Transakcije so podpisani podatkovni bloki, ki jih ustvarijo zunanji uporabniški računi.
Sestavni deli transakcije so:
\begin{itemize}
	\item prejemnik
	\item podpis pošiljatelja
	\item količina prenesenega ethra
	\item podatki (opcijsko)
	\item STARTGAS največje dovoljeno število izvedenih računskih operacij
	\item GASPRICE cena posamezne računske operacije
\end{itemize}

Sporočila so namenjena interni komunikaciji med pametnimi pogodbami.
So le navidezni objekti, obstajajo izključno v izvajalnem okolju.
Sestavlja jih:
\begin{itemize}
	\item pošiljatelj
	\item prejemnik
	\item količina prenesenega ethra
	\item STARTGAS
\end{itemize}
\cite{ethereumWhitepaper}

\subsection{Navidezni stroj Ethereum}

Navidezni stroj je glavna abstrakcija celotnega omrežja.
Je izvajalno okolje za pametne pogodbe v Ethereum omrežju in služi kot \sn{peskovnik} za izvajanje kode.
Celotni navidezni stroj lahko predstavimo s terko \textbf{(stanje blokov, transakcija, sporočilo, koda, spomin, sklad, programski števec, plin)}.
\textit{Stanje blokov} je predstavitev vseh računov s trenutnim stanjem ethra in shrambe.
Vsaka izvedena operacija zmanjša vrednost preostale količine plina, glede na uteženost posamezne operacije.
Transakcija se zaključi ob izvedbi zadnje operacije v programu oziroma s prekinitvijo, ko porabljena količina plina preseše največjo dovoljeno.


\subsubsection{Potrjevanje in kreiranje blokov}
Vsak blok v Ethereum verigi vsebuje kopijo vseh transakcij in zadnjega stanja omrežja.
Poleg tega sta v bloku zapisani tudi zaporedna številka bloka in zahtevnost.
Postopek validacije bloka poteka sledeče:
\begin{enumerate}
\item Preveri, če predhodni blok obstaja in je veljaven
\item Preveri časovni žig bloka - večji od prejšnejga bloka, vendar ne več kot 15 v prihodnosti
\item Preveri številko bloka, zahtevnost, izvor transakcije, izvor "strica" in omejitev količine plina
\item Preveri veljavnost \sn{Proof of Work}
\item Naj bo S[0] stanje na koncu predhodnega bloka
\item Naj bo TX seznam transakcij v bloku. Za vsak 
$\{i \mid 0,1,\dots, n-1\}$
je naslednje stanje
 $S[i+1] = APPLY(S[i], TX[i])$.
V primeru napake ali presežene omejitve količine plina na blok (GASLIMIT), vrni napako.
\item Naj $S_FINAL = S[n]$. Nagrada za najden blok se izplača samo najditelju.
\item Preveri, da je vrhnje vozlišče Merklovega drevesa \textbf{CITAT!!!} stanja $S_FINAL$ enaka končnemu stanju v bloku. V tem primeru je blok veljaven.
\end{enumerate}

Koda je izvedena s strani vseh sodelujočih entitet v omrežju. \cite{ethereumWhitepaper}

\section{Hyperledger}
Hyperledger je družina odprtokodnih projektov, namenjenih razvoju tehnologije veriženja podatkovnih blokov.
Projekt deluje pod okriljem organizacije The Linux Foundation, v sodelovanju s skupnostjo.
Med prvimi in najbolj znamimi izmed Hyperledger projektov je Hyperledger Fabric, prvotno razvit v podjetju IBM in Digital Asset.
Pod okrilje projekta Hyperledger spadajo še Sawtooth, Iroha, Burrow ter Indy.
Vsak izmed projektov na svoj način rešuje izzive s področja podatkovnih verig ali pa naslavlja ozko problemsko domeno, za primer: projekt Indy se ukvarja s problematiko spletne identitete uporabnika. \cite{hyperledgerWeb}
Trenutno najbolj znana in razširjena platforma je Fabric, trenutno v različici 1.1.
Od ostalih podobnih projektov se loči predvsem v konceptu privatnih omrežjih, pri katerih je sodelovanje omejeno s sistemom dovoljenj.
Omogoča modularno izbiro načina soglasja in ga je moč prilagajati zahtevam poslovnih uporabnikov. \cite{hyperledgerIbm}

\subsection{Fabric}
Hyperledger Fabric je v sami zasnovi namenjen poslovni uporabi.
Omogoča modularno in prilagodljivo arhitekturo, podobno kot ostale implementacije tehnologije veriženja blokov pozna tudi pametne pogodbe, tu imenovane \sn{chain code}.
Pametne pogodbe se tu izvajajo znotraj vsebnikov Docker in omogočajo implementacijo v poljubnem splošnonamenskem programskem jeziku.
Drugačen je tudi postopek izvedbe transakcije.

Celotno omrežje je zasnovano na predpostavki (delnega) zaupanja med sodelujočimi entitetami, za razliko od javnih omrežij.
Enostavna je menjava implementacije protokola za doseganje konsenza, bodisi na osnovi reševanja napak ob odpovedi (Crash Fault Tolerant -- CFT) ali ??? (Byzantine Fault Tolerance -- BFT).
Za samo delovanje ne potrebuje kriptovalute, potrjevanje transakcij in blokov pa ni nujno izvedeno s strani vseh sodelujočih, ampak le določene podmnožice, kar v teoriji omogoča paralelizacijo in posledično višjo zmogljivost.

\subsubsection{Modularnost}
Omrežje sestoji iz šestih osnovnih komponent, ki jih je moč poljubno menjati:
\begin{enumerate}
	\item urejevalnik (ordering service)
	\item upravitelj članstva (membership service) - povezuje zunanje entitete z njihovimi kriptografskimi predstavitvami
	\item P2P gossip protocol - opcijski
	\item Pametne pogodbe (chaincode) - procesno izolacijo zagotavlja izvajanje znotraj vsebnikov Docker. 
	Onemogočen je neposreden dostop do glavne knjige
	\item SUPB (DBMS)
	\item zamenljiva politika potrjevanja in validiranja
\end{enumerate}

\subsubsection{Pametne pogodbe}
Pametne pogodbe so delčki programske kode, ki se izvajajo kot distribuirane aplikacije.
Tri glavne značilnosti teh aplikacij so: veliko število sočasno izvajanih pametnih pogodb, dinamično dodajanje v omrežje in nevredne zaupanja.
Obstoječi načini izvajanja pogodb so umeščene v arhitekturo \textbf{uredi-izvedi}.
Za njih je značilno, da transakcije validirajo in sekvečno uredijo, temu pa sledi propagacija potrjenih blokov po omrežju.
Vsaka sodelujoča entitea nato transakcije izvede v tem vrstem redu.
Za enoličen način sekvenčnega izvajanja tu nastane potreba po novem, determinističnem programskem jeziku.
En izmed predstavnikov je programski jezik za programiranje pogodb v omrežju Ethereum, Solidity.
Ker je vsaka izmed transakcij izvedena s strani vsake entitete, to predstavlja veliko porabo razpoložljivih virov ter omejuje skaliranje ter performase.

Fabric pametne pogodbe izvaja po arhitekturi \textbf{izvedi-uredi-validiraj}.
Vsaka transakcija je najprej izvedena s čimer se preveri njeno pravilnost.
Nato je urejena, glede na protokol za doseganje konseza.
Nazadnje je transakcija validirana s strani za to pooblaščenih zunanjih entitet.
Tu v igro vstopi domensko specifična politika potrjevanja.
Slednje prinaša potencialno velike performančne prihranke.

\textbf{TODO:} dopolni s podrobnostmi

\chapter{Decentralizirano izvajanje}
\label{ch4}

\section{Registracija in odkrivanje storitev v decentraliziranem okolju}

Izvajanje storitev se danes seli v oblak, kjer se posamezne instance storitve replicira glede na trenutne potrebe.

Izvajanje storitev želimo decentralizirati - vsaka sodelujoča entiteta v omrežju lahko, pod določenimi pogoji, izvaja
katerokoli izmed nabora razpoložljivih storitev.
Prednost, ki jo prinaša decentralizirano izvajanje poslovne logike je praktično nemogoč napad zavrnitev storitve (DOS) in
porazdeljen napad zavrnitve storitve (DDOS).
Napadalec je zmožen posamezno sodelujočo entiteto v omrežju obremeniti do te mere, da le ta preneha z izvajanjem določene storitve.
Decentraliziran sistem bi v primeru prenehanja izvajanja storitve na eni entiteti izvajanje dodelil drugi. Postopek bi moral biti za končnega uporabnika storitve transparenten.

Dodatno se vsak klic storitve opremi s finančnimi podatki in ob uspešno izvedenem klicu je izvajalec za svoje delo nagrajen.

\section{Odkrivanje storitev v decentraliziranem okolju}
Predlagana rešitev registracije in odkrivanja storitve v decentraliziranem okolju je sestavljna iz naštetih komponent:
\begin{itemize}
	\item Registracija nove storitve \ref{registerService}
	\item Registracija izvajalcev \ref{registerWorker}
	\item Registracija izvajanja \ref{registerExecution}
	\item Odkrivanje storitev \ref{serviceDiscovery}
\end{itemize}

\subsection{Registracija nove storitve}
\label{registerService}
Vsak izmed sodelujočih ima možnost v omrežje javno objaviti novo storitev, za katero navede pogoje uporabe.
Izvorna koda oziroma izvršljiva datoteka storitve se shrani shrani v decentralizirano shrambo, temu pa sledi zapis podatkov o storivti v glavno knjigo.
Ob uspešni registraciji se v omrežju sproži dogodek, na katerega se sodelujoče entitete odzovejo.
Glede na lastne določene omejitve in trenutno aktivna naročila v omrežju, lahko poljuben člen omrežja prične z izvajanjem storitev.

\subsection{Registracija izvajalcev}
\label{registerWorker}
Vsaka digitalna identiteta lahko upravlja z več izvajalnimi enotami.
Ta pristop omogoča enemu uporabniškemu računu pripis vseh nagrad, ki jih posamezni izvajalec prisluži.
Podatki, ki se o posameznem izvajalcu zabeležijo so: lastnik (account), unikatna številka izvajalca (id) in naslov, preko katerega je izvajalec dosegljiv.
Posameznemu izvajalcu se lokalno konfigurira omejitve glede porabe sistemskih virov, ki jih lastnik nameni decentraliziranemu izvajanju storitev.

\subsection{Registracija izvajanja storitve}
\label{registerExecution}
Izvorno kodo oz. izvršljivo datoteko storitve se najprej pridobi iz omrežja.
Nadzorni proces nato storitev zažene, storitev sama pa ob inicializaciji sama izcede postopek registracije.
V glavno knjigo se zabeleži izvajalca in storitev, ki se izvaja.

\subsection{Odkrivanje storitve}
\label{serviceDiscovery}
Storitve, ki se trenutno izvajajo v omrežju, pridobimo z enostavnim vpogledom v glavno knjigo.
Med razpoložljivimi storitvami odjemalec izbere eno, pridobi podatke o lokaciji izvajanja in izvede klic po izbranem protokolu.
Od tu naprej komunikacija med storitvami poteka preko trenutnih protokolov (REST, gRPC, Event-driven).

TODO: Opis predlaganega koncepta za registracijo in odkrivanje storitev s pametnimi pogodbami.

Predvidoma do sredine junija, ko bo predvidoma znana končna zasnova.

\chapter{Implementacija in evalvacija rešitve}
\label{ch5}

\begin{figure}[h]
\includegraphics[width=1.0\textwidth]{slike/dApi.png}
\label{scheme}
\caption{Arhitekturna shema rešitve}
\end{figure}

Na sliki \ref{scheme} je prikazana shema predlagane rešitve. Osrednji del omrežja je nadzorni proces - 
dApi manager, ki dostopa do glavne knjige, decentralizirane shrambe in upravlja s storitvami, ki jih gostitelj izvaja.
Gostiteljski sistem v trenutni različici podpira upravljanje z vsebniki Docker.
Storitve, ki so na voljo za izvajanje so shranjene na datotečni shrambi IPFS, podatkovna veriga je 
osnovana na Ethereum verigi. Posamezne komponente sistema so podrobneje opisane v nadaljevanju.

\section{Nadzorni proces}
Nadzorni proces za izvajanje dApijev skrbi za:
\begin{itemize}
	\item registracijo novih storitev v omrežje, 
	\item prenos izvršljivih datotek v in iz omrežja,
	\item zagon, zaustavitev in upravljanje storitev
\end{itemize}

Komunikacija z nadzornim procesom trenutno poteka preko REST aplikacijskega vmesnika, v načrtu pa je implementacija vmesnikov za konzolni nadzor ter podpora novejšim komunikacijsim protokolom kot so gRPC, Apache Trift in podobni.

Za registracijo nove storitve nadzornemu procesu podamo pot do slike vsebnika Docker.
Sistem poskrbi za distribucijo slike v omrežje IPFS in podatke o storitvi doda v shrambo pogodbe na Ethereum omrežju.
Ob uspešni registraciji se proži dogodek, ki sodelujoče entitete obvesti o novi storitvi, pripravljeni na izvajanje.
Te se lahko na dogodek lahko odzovejo z zahtevo za izvajanje storitve.
Trenutno je izvajanje nove storitve potrebno prožiti ročno, ko bo pripravljen modul za razporejanje opravil, bo postopek v celoti avtomatiziran.
Pred pričetkom izvajanje se želeno storitev pridobi iz omrežja (IPFS), sliko vsebnika naloži v izvajalno okolje Docker in proži izvajanje.
Storitev nato sama poskrbi za registracijo in odkrivanje ostalih storitev v omrežju.

Razširitev obstoječe KumuluzEE konfiguracijske datoteke:

\begin{lstlisting}
dapi-manager:
  storage:
    remote:
      type: ipfs
      location: /ip4/127.0.0.1/tcp/5001
    local:
      downloadFolder: download
      execution:
  managers:
  - type: docker
    connection: tcp://192.168.99.100:2376
    tls: true
    certificate-path: /path/to/certificate
    instance-limit: 10
  blockchain:
    provider: ethereum
    host: http://127.0.0.1:8545
    account: /path/to/wallet
    password: password
\end{lstlisting}

\section{Decentralizirana shramba}
Izvršljive datoteke oziroma slike vsebnikov storitve je potrebno shraniti na način in lokacijo, kjer bodo dostopne vsem sodelujočim entitetam v omrežju.
Podobno, kot želimo izvajanje storitev decentralizirati, moramo poskrbeti tudi za decentralizirano shrambo.
V svoji implementaciji sem uporabil decentralizirano shrambo IPFS.
Gre za projekt, osnovan na omrežju Ethereum, namen projekta pa je shranjevanje datotek v porazdeljeni shrambi, dostop do njih pa preko omrežji P2P, podobno kot deluje protokol BitTorrent, po katerem se projekt tudi zgleduje.
Vsako datoteko, ki jo želimo shraniti v omrežje, odjemalec razbije na podatkovne bloke, izračuna zgoščeno vrednost posameznega bloka, te vrednosti pa nato sestavi v strukturo imenovano Merkle Tree.
Datoteko pridobimo enostavno preko zgoščene vrednosti v korenu drevesa.
Omrežje je sposobno poiskati posamezne koščke prvotne datoteke, vsebino posameznega pa hitro preveri z izračunom zgoščene vrednosti. V kolikor nam kdo želi podtakniti napačne bloke posamezne datoteke, sistem to prepozna in neveljavne bloke preprosto zavrže, ko od ostalih sodelujočih entitet prejme iste dele datoteke. Datoteka je veljavna, če sistem uspe sestaviti podatkovno strukturo Merkle Tree, katerega zgoščena vrednost v korenu drevesa je identična zahtevnani. \cite{Ipfs}

\section{Odjemalec za Ethereum omrežje}
Sistem za delovanje potrebuje odjemalca, ki se zna povezati v Ethereum omrežje.
V moji testni postavitvi je mesto odjemalca prevzel program Geth, implementacija Ethereum protokola v programskem jeziku Go. \cite{Geth}
Nadzorni proces se preko JSON RPC povezuje na lokalno instanco odjemalca Geth, decentralizirane storitve v izvajalnem okolju Docker pa se 
povezujejo na proces, dostopen preko mreže Infura.
Infura nam omogoča enostaven dostop do Ethereum omrežja, brez potrebe po lokalnem izvajanju Ehtereum protokola.
Za sodelovanje v decentraliziranem svetu nam lokalno ni potrebno namestiti ničesar, prav tako nam ni potrebno hraniti
celotne zgodovine - podatkovne verige. 
Na spletni strani se enostavno registriramo, s tem pridobimo unikaten ključ, ki nam omogoča dostop do oddaljenega izvajalca. \cite{Infura}


\section{Razširitev KumuluzEE platforme za podporo decentraliziranim aplikacijam}

\subsection{Priprava aplikacije}
V standardno KumuluzEE aplikacijo je potrebno vključiti razširitev \textit{kumuluz-dapi}. 
Razširitev ponuja nabor anotacij, s katerimi storitev bodisi registriramo v omrežje, bodisi določeno storitev poiščemo.
Potrebna je še dopolnitev konfiguracijske datoteke, v kateri podamo dodatne informacije o naši storitvi.
Ob zagonu storitve se preko anotacij poišče in registrira v omrežje.
V glavno knjigo se zapišejo podatki o izvajani storitvi, izvajalcu ter naslov, na katerem je storitev dostopna.

Za odkrivanje storitev poskrbi razširitev, ki v glavni knjigi poišče izvajalce storitve, med njimi pa na podlagi izbranega algoritma za razporejanje bremena, izbere enega izmed izvajalcev in pridobi naslov, na katerem se storitev trenutno izvaja.

Razširitev obstoječe KumuluzEE konfiguracijske datoteke:
\begin{lstlisting}
  dapi:
    blockchain:
      host: naslov izvajalca
      account: /pot/do/datoteke
      password: geslo
    type: docker
    storage: ipfs
    api: rest
\end{lstlisting}

V konfiguraciji so predvidene tudi trenutno neuporabljene nastavitve za tip izvršljive datoteke, v kateri shrambi se storitev nahaja in tip aplikacijskega vmesnika.
Trenutno sistem podpira le vsebnike Docker, ki jih je moč pridobiti preko omrežja IPFS, aplikacijski vmesnik pa je REST.


\section{Demo aplikacija}

Za namene demonstracije delovanja sistema sem implementiral dve preprosti REST storitvi.
Prva se ob zagonu registrira kot izvajalec, druga ob zagonu poišče prvo in nam ob klicu storitve le posreduje podatke, ki jih pridobi od prve.
Storitev ki se registrira v omrežje ima le eno izpostavljeno točko - seznam vseh uporabnikov.
Podobno velja za drugo, ki prvo storitev kliče in nam podatke samo posreduje naprej.


\section{Pomankljivosti trenutnega sistema in izboljšave v prihodnosti}

Implementirana rešitev je preprost dokaz zamišljenega koncepta in kot prva različica ponuja kar nekaj možnosti za izboljšave.
Prva izmed pomankljivosti je sama cena registracije in deregistracije storitev in njihovih izvajalcev.
Vsaka registracija novega izvajalca pomeni nov zapis na podatkovno verigo, kar v dinamičnem sistemu in ob trenutnih cenah transakcije na Ethereum omrežju predstavlja potencialno veliko finančno breme za izvajalca.
Zahtevnejša od prve je druga pomankljivost sistema in sicer deregistracija izvajalca.
Brisanje podatkov iz podatkovne verige je nemogoče zaradi same zasnove tehnologije - nespremenljivost.
S transakcijo je možno le navidezno brisati - razveljaviti preteklo transakcijo, zapis pa na podatkovni verigi ostane.
Brisanje je prav tako razmeroma draga operacija, posebno velik problem predstavlja brisanje izvajalca in s tem posledično še deregistracijo vseh storitev, ki jih je ta izvajalec v trenutku prekinitve izvajanja izvajal.

Dodatni mehanizmi, ki jih poznajo obstoječi sistemi za odkrivanje storitev, so še samodejna deregistracija storitve ob vnaprej določenem pretečenem času neaktivnosti.
Trenutna implementacija tega mehanizma še ne pozna, problem predstavlja predvsem decentralizacija.
V tem sistemu ne poznamo centralne storitve, ki bi ob določenem času iz registra preprosto brisala vse neaktivne storitve.
Sistem potrebuje nov mehanizem, ki bo znal med storitvami poiskati neaktivne in jih odstraniti iz registra. Kakšen bo mehanizem in princip delovanja sta v tem trenutku neznanka.

Sistem potrebuje tudi način prerazporejanja zahtev po omrežju.
Kdo izmed trenutno registriranih izvajalcev bo lahko najhitreje odgovoril?
Hiter odgovor je pogojen s fizično oddaljenostjo gostitelja od izvajalca, omrežnimi zakasnitvami, hitrost samega izvajalca. Reševanje teh izzivov je naslednja v vrsti, ki jih predstavlja celostna postavitev, v praksi uporabnega, sistema.


Vsakega izvajalca storitve želimo za uspešno izveden klic ustrezno finančno nagraditi. Tu se poraja več vrst odprtih vprašanj, izstopa predvsem vprašanje finančne vrednosti posameznega klica in način preverjanja pravilnosti izvedbe klica.
Je izvajalec dejansko pravilno izvedel zahtevano dejanje, tako kot je predvidel razvijalec in naročnik?
Potreben je mehanizem, ki ga zaenkrat imenujmo \sn{Proof of Execution}.
Podobno kot trenutni mehanizmi \sn{Proof of Work}, \sn{Proof of Stake} ter sorodni, ki jih uporabjajo decentralizirane podatkovne verige, potrebujemo mehanizem, preko katerega se bodo sodelujoče entitete v omrežju sposobne odločiti, ali je določen izvajalec pravilno izvedel zahtevano dejanje.
S tem področjem se trenutno aktivno ukvarjajo tudi pri startupu SONM, ki objublja računsko moč na zahtevo v decentraliziranem okolju. Iz oblačnega računalništva želijo preiti na t.i. \sn{računalniške storitve v megli} (fog computing). \cite{Sonm}

\chapter{Zaključek}
\label{stroka}

Proof of Execution, Scheduling, naročila izvajanja in potek avkcij
\textbf{TODO:} Glavne ugotovitve, povzetek narejenega. Kratka evalvacija.

Napisan ob zaključku dela.


\newpage %dodaj po potrebi, da bo številka strani za Literaturo v Kazalu pravilna!
\ \\
\clearpage
\addcontentsline{toc}{chapter}{Literatura}
\bibliographystyle{plain}
\bibliography{literatura}


\end{document}

